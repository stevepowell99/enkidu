<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Enkidu</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      :root {
        /* Gilgamesh palette: lapis lazuli + gold + sand */
        --enkidu-lapis: #0b3b7a;
        --enkidu-lapis2: #102a4c;
        --enkidu-gold: #c9a227;
        --enkidu-sand: #f3ead8;
        --enkidu-ink: #101828;
      }

      body.bg-light {
        color: var(--enkidu-ink);
        background:
          radial-gradient(1200px 600px at 10% 0%, rgba(201,162,39,0.20), transparent 60%),
          radial-gradient(900px 500px at 90% 10%, rgba(11,59,122,0.25), transparent 55%),
          linear-gradient(180deg, rgba(243,234,216,0.95), rgba(243,234,216,0.80));
      }

      /* Subtle cuneiform-style pattern (inline SVG) */
      body.bg-light::before {
        content: '';
        position: fixed;
        inset: 0;
        pointer-events: none;
        opacity: 0.08;
        background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A//www.w3.org/2000/svg'%20width%3D'220'%20height%3D'220'%20viewBox%3D'0%200%20220%20220'%3E%3Crect%20width%3D'220'%20height%3D'220'%20fill%3D'none'/%3E%3Cg%20fill%3D'%230b3b7a'%3E%3Crect%20x%3D'18'%20y%3D'22'%20width%3D'10'%20height%3D'42'%20rx%3D'2'/%3E%3Crect%20x%3D'34'%20y%3D'34'%20width%3D'34'%20height%3D'10'%20rx%3D'2'/%3E%3Crect%20x%3D'74'%20y%3D'22'%20width%3D'10'%20height%3D'42'%20rx%3D'2'/%3E%3Crect%20x%3D'96'%20y%3D'56'%20width%3D'52'%20height%3D'10'%20rx%3D'2'/%3E%3Crect%20x%3D'148'%20y%3D'30'%20width%3D'10'%20height%3D'36'%20rx%3D'2'/%3E%3Crect%20x%3D'26'%20y%3D'96'%20width%3D'58'%20height%3D'10'%20rx%3D'2'/%3E%3Crect%20x%3D'26'%20y%3D'114'%20width%3D'10'%20height%3D'52'%20rx%3D'2'/%3E%3Crect%20x%3D'52'%20y%3D'138'%20width%3D'66'%20height%3D'10'%20rx%3D'2'/%3E%3Crect%20x%3D'134'%20y%3D'108'%20width%3D'10'%20height%3D'62'%20rx%3D'2'/%3E%3Crect%20x%3D'150'%20y%3D'122'%20width%3D'44'%20height%3D'10'%20rx%3D'2'/%3E%3Crect%20x%3D'166'%20y%3D'150'%20width%3D'28'%20height%3D'10'%20rx%3D'2'/%3E%3C/g%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: 75% 18%;
        background-size: 560px 560px;
      }

      /* Basic markdown styling inside chat bubbles */
      #chatHistory code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      #chatHistory pre { background: rgba(0,0,0,0.05); padding: .75rem; border-radius: .5rem; overflow-x: auto; }
      #chatHistory p:last-child { margin-bottom: 0 !important; }
      .enkidu-typingDots span { display: inline-block; width: .5rem; text-align: center; animation: enkiduDotPulse 1.2s infinite; }
      .enkidu-typingDots span:nth-child(2) { animation-delay: .15s; }
      .enkidu-typingDots span:nth-child(3) { animation-delay: .30s; }
      @keyframes enkiduDotPulse { 0%, 80%, 100% { opacity: .2; } 40% { opacity: 1; } }

      .enkidu-hero {
        background: linear-gradient(135deg, rgba(11,59,122,0.92), rgba(16,42,76,0.92));
        border: 1px solid rgba(255,255,255,0.10);
      }

      .enkidu-hero .enkidu-title {
        letter-spacing: 0.4px;
      }

      .enkidu-hero .enkidu-subtitle {
        color: rgba(255,255,255,0.80);
      }

      .card.shadow-sm {
        border: 1px solid rgba(16,42,76,0.10);
      }

      .btn-primary {
        background-color: var(--enkidu-lapis);
        border-color: rgba(16,42,76,0.30);
      }
      .btn-primary:hover { background-color: #09407f; }

      .btn-warning {
        background-color: var(--enkidu-gold);
        border-color: rgba(0,0,0,0.10);
        color: #1b1405;
      }
      .btn-warning:hover { filter: brightness(0.98); }

      /* Simple collapsible tree */
      .enkidu-tree-node { user-select: none; }
      .enkidu-tree-toggle { display: inline-block; width: 1.25rem; text-align: center; cursor: pointer; }
      .enkidu-tree-label { cursor: pointer; }
    </style>
  </head>

  <body class="bg-light">
    <div class="container py-4">
      <div class="enkidu-hero rounded-4 shadow-sm p-3 p-md-4 mb-3">
        <div class="d-flex align-items-center justify-content-between">
          <div>
            <div class="h3 m-0 text-white enkidu-title">Enkidu</div>
            <div class="small enkidu-subtitle">Gilgamesh-flavoured, local-first assistant</div>
          </div>
          <div class="small enkidu-subtitle">UI</div>
        </div>
      </div>

      <div class="row g-3">
        <div class="col-12 col-lg-6">
          <div class="card shadow-sm">
            <div class="card-body">
              <h2 class="h5">Work</h2>
              <div class="row g-2 align-items-end mb-2">
                <div class="col-12 col-sm-6">
                  <label class="form-label small text-muted">Model</label>
                  <div id="modelGroup" class="btn-group w-100" role="group" aria-label="Model">
                    <input type="radio" class="btn-check" name="modelRadio" id="m52" autocomplete="off" value="gpt-5.2">
                    <label class="btn btn-outline-primary" for="m52" title="gpt-5.2 — output $14.00 / 1M tokens">5.2</label>

                    <input type="radio" class="btn-check" name="modelRadio" id="m5mini" autocomplete="off" value="gpt-5-mini">
                    <label class="btn btn-outline-primary" for="m5mini" title="gpt-5-mini — output $2.00 / 1M tokens">5-mini</label>

                    <input type="radio" class="btn-check" name="modelRadio" id="m5nano" autocomplete="off" value="gpt-5-nano">
                    <label class="btn btn-outline-primary" for="m5nano" title="gpt-5-nano — output $0.40 / 1M tokens">5-nano</label>

                    <input type="radio" class="btn-check" name="modelRadio" id="m4omini" autocomplete="off" value="gpt-4o-mini">
                    <label class="btn btn-outline-primary" for="m4omini" title="gpt-4o-mini — output $0.60 / 1M tokens">4o-mini</label>
                  </div>
                </div>
                <div class="col-12 col-sm-6"></div>
              </div>
              <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="debugLog">
                <label class="form-check-label small text-muted" for="debugLog">Debug: log full Work payloads to JS console (planEcho.userContent etc.)</label>
              </div>
              <div id="chatHistory" class="border rounded bg-white p-2 mb-2" style="height: 420px; overflow-y: auto;"></div>
              <div class="mb-2">
                <textarea id="workPrompt" class="form-control" rows="3" placeholder="Message (Enter to send, Shift+Enter for newline)..."></textarea>
              </div>
              <div class="d-flex gap-2 flex-wrap">
                <button id="workBtn" class="btn btn-primary">Run</button>
                <button id="workBtnNow" class="btn btn-outline-primary">RunNow</button>
                <button id="clearHistoryBtn" class="btn btn-outline-secondary">Start over</button>
              </div>
              <div id="workStatus" class="mt-2 small text-muted"></div>
              <div id="autoCaptureStatus" class="small text-muted"></div>
              <details class="mt-2">
                <summary class="small text-muted">Used memories</summary>
                <div id="usedMemories" class="small mt-1"></div>
              </details>
              <details class="mt-2">
                <summary class="small text-muted">Used sources</summary>
                <div id="usedSources" class="small mt-1"></div>
              </details>
            </div>
          </div>
        </div>

        <div class="col-12 col-lg-6">
          <div class="card shadow-sm">
            <div class="card-body">
              <h2 class="h5">Dream + Diary</h2>
              <div class="d-flex gap-2 flex-wrap">
                <button id="dreamBtn" class="btn btn-warning">Run Dream</button>
                <button id="refreshDiaryBtn" class="btn btn-outline-secondary">Refresh diary list</button>
              </div>
              <div class="row g-2 mt-2">
                <div class="col-12 col-lg-4">
                  <div class="small text-muted mb-1">Diary entries</div>
                  <select id="diarySelect" class="form-select" size="8"></select>
                </div>
                <div class="col-12 col-lg-8">
                  <div class="small text-muted mb-1">Diary content</div>
                  <pre id="diaryOut" class="p-2 bg-body-tertiary border rounded" style="white-space:pre-wrap; min-height: 12rem;"></pre>
                </div>
              </div>
            </div>
          </div>

          <div class="card shadow-sm mt-3">
            <div class="card-body">
              <h2 class="h5">Sources (ingest)</h2>
              <div class="small text-muted">Ingest either a folder of markdown files or pasted text. Enkidu will store verbatim sources and create curated memory notes.</div>
              <div class="row g-2 mt-2">
                <div class="col-12 col-lg-4">
                  <label class="form-label small text-muted mb-1">Source set name (optional)</label>
                  <input id="sourcesMetaName" class="form-control" placeholder="e.g. Causal map app docs"/>
                </div>
                <div class="col-12 col-lg-4">
                  <label class="form-label small text-muted mb-1">Default tags (optional)</label>
                  <input id="sourcesMetaTags" class="form-control" placeholder="comma,separated,tags"/>
                </div>
                <div class="col-12 col-lg-4">
                  <label class="form-label small text-muted mb-1">Context (what are these files?)</label>
                  <input id="sourcesMetaContext" class="form-control" placeholder="one-line description (helps tagging + filing)"/>
                </div>
              </div>
              <div class="row g-2 mt-2">
                <div class="col-12 col-lg-4">
                  <label class="form-label small text-muted mb-1">Default folder</label>
                  <select id="sourcesMetaDest" class="form-select">
                    <option value="auto" selected>auto (model decides)</option>
                    <option value="inbox">inbox</option>
                    <option value="projects">projects</option>
                    <option value="howto">howto</option>
                    <option value="people">people</option>
                  </select>
                </div>
                <div class="col-12 col-lg-8">
                  <div class="small text-muted" style="padding-top: 2.0rem;">
                    Tip: set this if the model keeps filing everything in the wrong place.
                  </div>
                </div>
              </div>
              <div class="row g-2 align-items-end mt-1">
                <div class="col-12 col-lg-8">
                  <div class="d-flex align-items-center gap-2 mb-2">
                    <div class="form-check">
                      <input class="form-check-input" type="radio" name="sourcesMode" id="sourcesModeFolder" value="folder" checked>
                      <label class="form-check-label small" for="sourcesModeFolder">Folder</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input" type="radio" name="sourcesMode" id="sourcesModeText" value="text">
                      <label class="form-check-label small" for="sourcesModeText">Paste text</label>
                    </div>
                    <div class="small text-muted">(same tags/context apply to both)</div>
                  </div>

                  <div id="sourcesFolderWrap">
                    <input id="sourcesFolder" class="form-control" type="file" webkitdirectory multiple />
                    <div class="small text-muted mt-1">Tip: dotfiles/dotfolders are ignored.</div>
                  </div>

                  <div id="sourcesTextWrap" style="display:none;">
                    <textarea id="sourcesText" class="form-control" rows="7" placeholder="Paste any text or markdown here..."></textarea>
                    <div class="row g-2 mt-2">
                      <div class="col-12 col-lg-6">
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="sourcesSplitLong" checked>
                          <label class="form-check-label small" for="sourcesSplitLong">Split long text into parts (better summaries + embeddings)</label>
                        </div>
                        <div class="input-group input-group-sm mt-1" style="max-width: 340px;">
                          <span class="input-group-text">Max chars/part</span>
                          <input id="sourcesSplitMaxChars" class="form-control" type="number" min="2000" max="80000" step="1000" value="12000">
                        </div>
                        <div class="small text-muted mt-1">Splits on markdown headings when possible; otherwise chunk by size.</div>
                      </div>
                      <div class="col-12 col-lg-6">
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="sourcesDreamAfter">
                          <label class="form-check-label small" for="sourcesDreamAfter">Auto-organise after ingest (run Dream)</label>
                        </div>
                        <div class="small text-muted mt-1">Dream can move/merge new notes; diary will record what it did.</div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="col-12 col-lg-4">
                  <div class="d-flex gap-2">
                    <button id="ingestSourcesBtn" class="btn btn-outline-primary w-100">Ingest</button>
                    <button id="clearSourcesBtn" class="btn btn-outline-secondary w-100">Clear</button>
                  </div>
                </div>
              </div>
              <div id="sourcesStatus" class="small text-muted mt-2"></div>
            </div>
          </div>
        </div>

        <div class="col-12">
          <div class="card shadow-sm">
            <div class="card-body">
              <h2 class="h5">Memories browser</h2>
              <div class="row g-2">
                <div class="col-12 col-lg-4">
                  <div class="small text-muted mb-1">Tree</div>
                  <div id="memTree" class="border rounded bg-white p-2" style="max-height: 420px; overflow:auto;"></div>
                </div>
                <div class="col-12 col-lg-8">
                  <div class="small text-muted mb-1">File content</div>
                  <pre id="fileOut" class="p-2 bg-body-tertiary border rounded" style="white-space:pre-wrap; min-height: 12rem;"></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Minimal, safe markdown renderer (escape first; render a small subset).
      function escapeHtml(s) {
        return String(s || '')
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }

      function renderMarkdown(md) {
        let s = escapeHtml(md);

        // Fenced code blocks
        const tick = String.fromCharCode(96);
        const fence = tick + tick + tick;
        const fenceRe = new RegExp(fence + '([\\s\\S]*?)' + fence, 'g');
        s = s.replace(fenceRe, (m, code) => {
          return '<pre class="mb-0"><code>' + code.replace(/^\n|\n$/g, '') + '</code></pre>';
        });

        // Inline code
        const inlineCodeRe = new RegExp(tick + '([^' + tick + ']*)' + tick, 'g');
        s = s.replace(inlineCodeRe, '<code>$1</code>');

        // Bold **...**
        s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

        // Italic *...*
        s = s.replace(/(^|[^*])\*([^*]+)\*([^*]|$)/g, '$1<em>$2</em>$3');

        // Links [text](url) - only allow http(s)
        s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, url) => {
          const u = String(url || '').trim();
          if (!/^https?:\/\//i.test(u)) return text;
          return '<a href="' + u + '" target="_blank" rel="noopener noreferrer">' + text + '</a>';
        });

        // Paragraphs / line breaks (avoid touching <pre> blocks)
        const parts = s.split(/(<pre[\s\S]*?<\/pre>)/g);
        for (let i = 0; i < parts.length; i++) {
          if (parts[i].startsWith('<pre')) continue;
          parts[i] = parts[i]
            .split(/\n\n+/)
            .map(p => '<p class="mb-2">' + p.replace(/\n/g, '<br>') + '</p>')
            .join('');
        }
        s = parts.join('');
        return s;
      }

      async function postJson(url, obj) {
        try {
          if (isDebugLogEnabled()) {
            console.groupCollapsed('[enkidu] POST ' + url);
            console.log('request', obj);
          }
          const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(obj) });
          const text = await r.text();
          let out;
          try { out = JSON.parse(text); } catch { out = { error: text || ('HTTP ' + r.status) }; }
          if (isDebugLogEnabled()) {
            console.log('response', out);
            console.groupEnd();
          }
          return out;
        } catch (e) {
          if (isDebugLogEnabled()) {
            console.warn('[enkidu] POST failed ' + url, e);
            try { console.groupEnd(); } catch {}
          }
          return { error: (e && e.message) ? e.message : String(e) };
        }
      }

      async function getJson(url) {
        try {
          const r = await fetch(url);
          const text = await r.text();
          try { return JSON.parse(text); } catch { return { error: text || ('HTTP ' + r.status) }; }
        } catch (e) {
          return { error: (e && e.message) ? e.message : String(e) };
        }
      }

      const workBtn = document.getElementById('workBtn');
      const workBtnNow = document.getElementById('workBtnNow');
      const workPrompt = document.getElementById('workPrompt');
      const clearHistoryBtn = document.getElementById('clearHistoryBtn');
      const chatHistoryEl = document.getElementById('chatHistory');
      const workStatus = document.getElementById('workStatus');
      const usedMemoriesEl = document.getElementById('usedMemories');
      const autoCaptureStatusEl = document.getElementById('autoCaptureStatus');
      const usedSourcesEl = document.getElementById('usedSources');
      const debugLogEl = document.getElementById('debugLog');

      function isDebugLogEnabled() {
        return !!(debugLogEl && debugLogEl.checked);
      }

      // Persist debug checkbox (browser-local).
      debugLogEl.checked = (localStorage.getItem('enkidu.debugLog') === 'true');
      debugLogEl.addEventListener('change', () => {
        localStorage.setItem('enkidu.debugLog', debugLogEl.checked ? 'true' : 'false');
      });

      const sourcesFolderEl = document.getElementById('sourcesFolder');
      const ingestSourcesBtn = document.getElementById('ingestSourcesBtn');
      const clearSourcesBtn = document.getElementById('clearSourcesBtn');
      const sourcesStatusEl = document.getElementById('sourcesStatus');
      const sourcesMetaNameEl = document.getElementById('sourcesMetaName');
      const sourcesMetaTagsEl = document.getElementById('sourcesMetaTags');
      const sourcesMetaContextEl = document.getElementById('sourcesMetaContext');
      const sourcesMetaDestEl = document.getElementById('sourcesMetaDest');
      const sourcesModeFolderEl = document.getElementById('sourcesModeFolder');
      const sourcesModeTextEl = document.getElementById('sourcesModeText');
      const sourcesFolderWrapEl = document.getElementById('sourcesFolderWrap');
      const sourcesTextWrapEl = document.getElementById('sourcesTextWrap');
      const sourcesTextEl = document.getElementById('sourcesText');
      const sourcesSplitLongEl = document.getElementById('sourcesSplitLong');
      const sourcesSplitMaxCharsEl = document.getElementById('sourcesSplitMaxChars');
      const sourcesDreamAfterEl = document.getElementById('sourcesDreamAfter');

      function getSourcesMode() {
        return sourcesModeTextEl && sourcesModeTextEl.checked ? 'text' : 'folder';
      }

      function updateSourcesModeUi() {
        const mode = getSourcesMode();
        if (sourcesFolderWrapEl) sourcesFolderWrapEl.style.display = (mode === 'folder') ? '' : 'none';
        if (sourcesTextWrapEl) sourcesTextWrapEl.style.display = (mode === 'text') ? '' : 'none';
        sourcesStatusEl.textContent = '';
      }

      if (sourcesModeFolderEl) sourcesModeFolderEl.addEventListener('change', updateSourcesModeUi);
      if (sourcesModeTextEl) sourcesModeTextEl.addEventListener('change', updateSourcesModeUi);

      // Persist sources metadata (browser-local).
      function loadSourcesMeta() {
        return {
          name: localStorage.getItem('enkidu.sourcesMeta.name') || '',
          tags: localStorage.getItem('enkidu.sourcesMeta.tags') || '',
          context: localStorage.getItem('enkidu.sourcesMeta.context') || '',
          dest: localStorage.getItem('enkidu.sourcesMeta.dest') || 'auto',
        };
      }
      function saveSourcesMeta(meta) {
        localStorage.setItem('enkidu.sourcesMeta.name', meta.name || '');
        localStorage.setItem('enkidu.sourcesMeta.tags', meta.tags || '');
        localStorage.setItem('enkidu.sourcesMeta.context', meta.context || '');
        localStorage.setItem('enkidu.sourcesMeta.dest', meta.dest || 'auto');
      }
      const _meta0 = loadSourcesMeta();
      sourcesMetaNameEl.value = _meta0.name;
      sourcesMetaTagsEl.value = _meta0.tags;
      sourcesMetaContextEl.value = _meta0.context;
      sourcesMetaDestEl.value = _meta0.dest || 'auto';
      [sourcesMetaNameEl, sourcesMetaTagsEl, sourcesMetaContextEl, sourcesMetaDestEl].forEach(el => {
        el.addEventListener('input', () => {
          saveSourcesMeta({
            name: sourcesMetaNameEl.value,
            tags: sourcesMetaTagsEl.value,
            context: sourcesMetaContextEl.value,
            dest: sourcesMetaDestEl.value,
          });
        });
      });

      function currentSourcesMeta() {
        return {
          name: (sourcesMetaNameEl.value || '').trim(),
          tags: (sourcesMetaTagsEl.value || '').trim(),
          context: (sourcesMetaContextEl.value || '').trim(),
          default_dest: (sourcesMetaDestEl.value || 'auto').trim(),
        };
      }

      function selectedMdFiles() {
        return Array.from(sourcesFolderEl.files || []).filter(f => {
          const name = String(f.name || '');
          const rel = String(f.webkitRelativePath || '');
          if (name.startsWith('.')) return false;
          if (rel.split('/').some(p => p.startsWith('.'))) return false;
          return name.toLowerCase().endsWith('.md');
        });
      }

      sourcesFolderEl.addEventListener('change', async () => {
        const files = selectedMdFiles();
        sourcesStatusEl.textContent = files.length ? ('Selected ' + files.length + ' .md file(s).') : '';
      });

      ingestSourcesBtn.onclick = async () => {
        const mode = getSourcesMode();
        const meta = currentSourcesMeta();

        ingestSourcesBtn.disabled = true;
        clearSourcesBtn.disabled = true;
        sourcesStatusEl.textContent = 'Ingesting... (preparing)';

        const model = getSelectedModel();
        let done = 0;
        let createdMem = 0;
        let createdSrc = 0;
        const batchSize = 5;

        try {
          if (mode === 'text') {
            const text = String(sourcesTextEl.value || '').trim();
            if (!text) {
              sourcesStatusEl.textContent = 'No text to ingest.';
              return;
            }
            const slug = slugifyForPath(meta.name || meta.context || text.slice(0, 80));
            const base = 'pasted/' + tsForPath() + '_' + slug;

            function splitByHeadingsOrSize(s, maxChars) {
              const lines = String(s || '').split(/\r?\n/);
              const headingRe = /^#{1,3}\s+\S/;
              let hasHeadings = false;
              for (const ln of lines) { if (headingRe.test(ln)) { hasHeadings = true; break; } }

              // Step 1: split into sections (by heading) if available; otherwise one big section.
              const sections = [];
              if (hasHeadings) {
                let cur = [];
                for (const ln of lines) {
                  if (headingRe.test(ln) && cur.length) {
                    sections.push(cur.join('\n').trim());
                    cur = [];
                  }
                  cur.push(ln);
                }
                if (cur.length) sections.push(cur.join('\n').trim());
              } else {
                sections.push(String(s || '').trim());
              }

              // Step 2: pack sections into chunks <= maxChars; if a single section is too big, hard-slice it.
              const chunks = [];
              let buf = '';
              function flush() {
                const t = buf.trim();
                if (t) chunks.push(t);
                buf = '';
              }

              for (const sec of sections) {
                const part = (sec || '').trim();
                if (!part) continue;

                if (!buf) {
                  if (part.length <= maxChars) {
                    buf = part;
                  } else {
                    // Hard-slice huge section on nearest newline boundary.
                    let rest = part;
                    while (rest.length > maxChars) {
                      let cut = rest.lastIndexOf('\n', maxChars);
                      if (cut < Math.floor(maxChars * 0.6)) cut = maxChars;
                      chunks.push(rest.slice(0, cut).trim());
                      rest = rest.slice(cut).trim();
                    }
                    if (rest) buf = rest;
                  }
                  continue;
                }

                if ((buf.length + 2 + part.length) <= maxChars) {
                  buf = buf + '\n\n' + part;
                } else {
                  flush();
                  if (part.length <= maxChars) {
                    buf = part;
                  } else {
                    let rest = part;
                    while (rest.length > maxChars) {
                      let cut = rest.lastIndexOf('\n', maxChars);
                      if (cut < Math.floor(maxChars * 0.6)) cut = maxChars;
                      chunks.push(rest.slice(0, cut).trim());
                      rest = rest.slice(cut).trim();
                    }
                    if (rest) buf = rest;
                  }
                }
              }
              flush();
              return chunks;
            }

            let maxChars = parseInt(String(sourcesSplitMaxCharsEl && sourcesSplitMaxCharsEl.value ? sourcesSplitMaxCharsEl.value : '12000'), 10);
            if (!Number.isFinite(maxChars) || maxChars < 2000) maxChars = 12000;
            if (maxChars > 80000) maxChars = 80000;

            const wantSplit = !!(sourcesSplitLongEl && sourcesSplitLongEl.checked);
            const chunks = (wantSplit && text.length > maxChars) ? splitByHeadingsOrSize(text, maxChars) : [text];
            const files = chunks.length === 1
              ? [{ path: base + '.md', content: chunks[0] }]
              : chunks.map((c, i) => ({
                  path: base + '_part' + String(i + 1).padStart(2, '0') + '.md',
                  content: c
                }));

            sourcesStatusEl.textContent = 'Ingesting... uploading text (' + files.length + ' part(s))';
            const resp = await postJson('/api/sources/ingest', { model, meta, files });
            if (resp && resp.error) {
              sourcesStatusEl.textContent = 'Error: ' + resp.error;
              return;
            }
            createdMem += (resp.createdMemories || []).length;
            createdSrc += (resp.createdSources || []).length;
            sourcesStatusEl.textContent = 'Done. Created ' + createdMem + ' memory notes; stored ' + createdSrc + ' source file(s).';

            if (sourcesDreamAfterEl && sourcesDreamAfterEl.checked) {
              sourcesStatusEl.textContent += ' Organising... (Dream)';
              await doDream(model);
            }
            return;
          }

          const files = selectedMdFiles();
          if (!files.length) {
            sourcesStatusEl.textContent = 'No .md files selected.';
            return;
          }
          for (let i = 0; i < files.length; i += batchSize) {
            const batch = files.slice(i, i + batchSize);
            const payloadFiles = [];
            for (const f of batch) {
              sourcesStatusEl.textContent = 'Ingesting... reading ' + (done + payloadFiles.length + 1) + '/' + files.length;
              const rel = f.webkitRelativePath || f.name;
              payloadFiles.push({ path: rel, content: await f.text() });
            }
            sourcesStatusEl.textContent = 'Ingesting... uploading batch ' + (Math.floor(i / batchSize) + 1) + '/' + Math.ceil(files.length / batchSize);
            const resp = await postJson('/api/sources/ingest', { model, meta, files: payloadFiles });
            if (resp && resp.error) {
              sourcesStatusEl.textContent = 'Error: ' + resp.error;
              return;
            }
            createdMem += (resp.createdMemories || []).length;
            createdSrc += (resp.createdSources || []).length;
            done += batch.length;
            sourcesStatusEl.textContent =
              'Ingesting... processed ' + done + '/' + files.length +
              ' files. Created ' + createdMem + ' memory notes; stored ' + createdSrc + ' sources.';
          }
          sourcesStatusEl.textContent = 'Done. Created ' + createdMem + ' memory notes; stored ' + createdSrc + ' source file(s).';
        } finally {
          ingestSourcesBtn.disabled = false;
          clearSourcesBtn.disabled = false;
        }
      };

      clearSourcesBtn.onclick = () => {
        sourcesFolderEl.value = '';
        sourcesTextEl.value = '';
        sourcesStatusEl.textContent = '';
      };

      function slugifyForPath(s) {
        return String(s || '')
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '') || 'pasted';
      }

      function tsForPath() {
        // 20251224t174859z
        return new Date().toISOString().toLowerCase().replace(/[-:]/g, '').replace(/\.\d{3}z$/, 'z');
      }

      updateSourcesModeUi();

      // Persist model selection (radio buttons).
      const MODEL_DEFAULT = 'gpt-5-mini';
      function getSelectedModel() {
        const el = document.querySelector('input[name="modelRadio"]:checked');
        return (el && el.value) ? el.value : MODEL_DEFAULT;
      }
      function setSelectedModel(id) {
        const el = document.querySelector('input[name="modelRadio"][value="' + id + '"]');
        if (el) el.checked = true;
      }
      setSelectedModel(localStorage.getItem('enkidu.model') || MODEL_DEFAULT);
      document.querySelectorAll('input[name="modelRadio"]').forEach(el => {
        el.addEventListener('change', () => localStorage.setItem('enkidu.model', getSelectedModel()));
      });

      // Chat history (browser-local).
      function loadHistory() {
        try { return JSON.parse(localStorage.getItem('enkidu.chatHistory') || '[]'); } catch { return []; }
      }
      function saveHistory(h) {
        localStorage.setItem('enkidu.chatHistory', JSON.stringify(h));
      }
      function renderHistory() {
        const h = loadHistory();
        chatHistoryEl.innerHTML = '';
        for (const m of h) {
          const row = document.createElement('div');
          row.className = 'd-flex mb-2';

          const bubble = document.createElement('div');
          bubble.className = 'p-2 border rounded';
          bubble.style.whiteSpace = 'pre-wrap';
          bubble.style.maxWidth = '85%';
          bubble.innerHTML = renderMarkdown(m.content);

          if (m.role === 'user') {
            row.className += ' justify-content-end';
            bubble.className += ' bg-primary-subtle';
          } else {
            row.className += ' justify-content-start';
            bubble.className += ' bg-body-tertiary';
          }

          row.appendChild(bubble);
          chatHistoryEl.appendChild(row);
        }
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
      }

      function addTypingIndicator(label) {
        const row = document.createElement('div');
        row.className = 'd-flex mb-2 justify-content-start';
        row.id = 'typingIndicatorRow';

        const bubble = document.createElement('div');
        bubble.className = 'p-2 border rounded bg-body-tertiary';
        bubble.style.whiteSpace = 'pre-wrap';
        bubble.style.maxWidth = '85%';
        const txt = (label || 'Thinking').toString();
        bubble.innerHTML = escapeHtml(txt) + ' <span class="enkidu-typingDots"><span>.</span><span>.</span><span>.</span></span>';

        row.appendChild(bubble);
        chatHistoryEl.appendChild(row);
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
      }

      function setTypingIndicatorLabel(label) {
        const row = document.getElementById('typingIndicatorRow');
        if (!row) return addTypingIndicator(label);
        const bubble = row.querySelector('div');
        if (!bubble) return addTypingIndicator(label);
        const txt = (label || 'Thinking').toString();
        bubble.innerHTML = escapeHtml(txt) + ' <span class="enkidu-typingDots"><span>.</span><span>.</span><span>.</span></span>';
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
      }

      function removeTypingIndicator() {
        const el = document.getElementById('typingIndicatorRow');
        if (el) el.remove();
      }

      // Enter runs Work (Shift+Enter keeps newline).
      workPrompt.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          workBtn.click();
        }
      });

      async function doWork(runNow) {
        workStatus.textContent = 'Working...';
        workBtn.disabled = true;
        workBtnNow.disabled = true;
        addTypingIndicator(runNow ? 'Planning (RunNow)' : 'Planning (route + retrieval)');
        const model = getSelectedModel();
        const history = loadHistory();
        let resp = null;
        try {
          usedMemoriesEl.textContent = runNow ? '(skipped: RunNow)' : '(planning...)';
          usedSourcesEl.textContent = runNow ? '(skipped: RunNow)' : '(planning...)';

          const plan = await postJson('/api/work/plan', { prompt: workPrompt.value, model, history, runNow: !!runNow });
          if (plan && plan.error) {
            resp = plan;
            return;
          }
          if (isDebugLogEnabled()) {
            window.__enkidu_lastWorkPlan = plan;
            window.__enkidu_lastWorkPlanEcho = plan.planEcho;
            console.log('[enkidu] saved window.__enkidu_lastWorkPlanEcho (includes userContent)');
          }

          // Update retrieval UI before the model answers.
          if (!runNow && plan && Array.isArray(plan.usedMemories)) {
            const ms = plan.usedMemories;
            if (!ms.length) usedMemoriesEl.textContent = '(none)';
            else usedMemoriesEl.innerHTML = ms
              .map(m => '<div><code>' + escapeHtml(m.path || '') + '</code> — ' + escapeHtml(m.title || '') + ' <span class="text-muted">(imp ' + escapeHtml(String(m.importance ?? 0)) + ')</span></div>')
              .join('');
          }
          if (!runNow && plan && Array.isArray(plan.usedSources)) {
            const ss = plan.usedSources;
            if (!ss.length) usedSourcesEl.textContent = '(none)';
            else usedSourcesEl.innerHTML = ss.map(s => '<div><code>' + escapeHtml(s.path || '') + '</code></div>').join('');
          }

          // Bubble: prove the stages are real.
          const r = (plan && plan.route) ? plan.route : {};
          const memN = (plan && Array.isArray(plan.usedMemories)) ? plan.usedMemories.length : 0;
          const srcN = (plan && Array.isArray(plan.usedSources)) ? plan.usedSources.length : 0;
          const lim = (plan && plan.limits) ? plan.limits : {};
          const memCap = (lim && typeof lim.memTopN !== 'undefined') ? lim.memTopN : 5;
          const srcCap = (lim && typeof lim.srcTopN !== 'undefined') ? lim.srcTopN : 3;
          const flags = [];
          if (r.needRecency) flags.push('recency');
          if (r.needExpansion) flags.push('expand');
          setTypingIndicatorLabel('Answering (mem ' + memN + '/' + memCap + ', src ' + srcN + '/' + srcCap + (flags.length ? '; ' + flags.join('+') : '') + ')');

          resp = await postJson('/api/work/answer', { planToken: plan.planToken, planEcho: plan.planEcho });
          if (isDebugLogEnabled()) {
            window.__enkidu_lastWorkAnswer = resp;
            console.log('[enkidu] saved window.__enkidu_lastWorkAnswer');
          }
        } finally {
          workBtn.disabled = false;
          workBtnNow.disabled = false;
        }
        workStatus.textContent = resp && resp.error ? ('Error: ' + resp.error) : '';
        if (resp && resp.capturePath) autoCaptureStatusEl.textContent = 'Captured: ' + resp.capturePath;
        else autoCaptureStatusEl.textContent = '';

        if (resp && resp.error && !resp.answer) {
          const h = loadHistory();
          h.push({ role: 'assistant', content: 'Error:\n' + String(resp.error) });
          saveHistory(h.slice(-20));
          renderHistory();
          removeTypingIndicator();
          return;
        }

        if (resp && resp.answer) {
          const h = loadHistory();
          h.push({ role: 'user', content: workPrompt.value });
          h.push({ role: 'assistant', content: resp.answer });
          saveHistory(h.slice(-20));
          renderHistory();
          workPrompt.value = '';
        }

        removeTypingIndicator();
      }

      workBtn.onclick = async () => doWork(false);
      workBtnNow.onclick = async () => doWork(true);

      clearHistoryBtn.onclick = () => {
        saveHistory([]);
        renderHistory();
        workPrompt.value = '';
        workStatus.textContent = '';
        autoCaptureStatusEl.textContent = '';
        usedMemoriesEl.textContent = '';
        usedSourcesEl.textContent = '';
      };

      const dreamBtn = document.getElementById('dreamBtn');
      const refreshDiaryBtn = document.getElementById('refreshDiaryBtn');
      const diarySelect = document.getElementById('diarySelect');
      const diaryOut = document.getElementById('diaryOut');

      async function doDream(model) {
        dreamBtn.disabled = true;
        refreshDiaryBtn.disabled = true;
        diaryOut.textContent = 'Dream: planning (catalog + duplicates)...';
        let ticker = null;
        const started = Date.now();
        function startTicker(prefix) {
          if (ticker) clearInterval(ticker);
          ticker = setInterval(() => {
            const s = Math.floor((Date.now() - started) / 1000);
            diaryOut.textContent = (prefix || diaryOut.textContent || 'Dream...') + '\n\n(elapsed: ' + s + 's)';
          }, 1000);
        }
        try {
          const plan = await postJson('/api/dream/plan', { model: model || getSelectedModel() });
          if (plan && plan.error) {
            diaryOut.textContent = plan.error || 'Error';
            return plan;
          }
          const sum = plan.summary || {};
          const wr = Array.isArray(plan.wantRead) ? plan.wantRead : [];
          diaryOut.textContent =
            'Dream plan complete.\n' +
            '- notes: ' + (sum.note_count_total ?? '?') + '\n' +
            '- catalog: ' + (sum.catalog_count ?? '?') + '\n' +
            '- reading: ' + wr.length + ' file(s)\n' +
            '- dupes: ' + ((sum.duplicates && sum.duplicates.exact_groups) ?? 0) + ' exact groups; ' +
              ((sum.duplicates && sum.duplicates.near_pairs) ?? 0) + ' near pairs\n' +
            (plan.note ? ('\nNote: ' + plan.note + '\n') : '') +
            (wr.length ? ('\nWill read:\n' + wr.slice(0, 25).map(p => '- ' + p).join('\n') + (wr.length > 25 ? '\n- ...' : '') + '\n') : '');

          diaryOut.textContent += '\nDream: executing (reading + applying ops + writing diary)...';
          startTicker(diaryOut.textContent);
          const exec = await postJson('/api/dream/execute', { planToken: plan.planToken, model: model || getSelectedModel(), wantRead: wr });
          if (exec && exec.error) {
            diaryOut.textContent = exec.error || 'Error';
            return exec;
          }
          // Refresh and display new diary immediately.
          await refreshDiary();
          if (exec && exec.diaryPath) {
            const found = Array.from(diarySelect.options).find(o => o.value === exec.diaryPath);
            if (found) {
              diarySelect.value = exec.diaryPath;
              diaryOut.textContent = exec.diary || 'Dream complete. Diary written: ' + exec.diaryPath;
            } else {
              diaryOut.textContent = exec.diary || ('Dream complete. Diary written: ' + exec.diaryPath);
            }
          } else {
            diaryOut.textContent = exec && exec.diary ? exec.diary : 'Dream complete.';
          }
          if (exec && exec.embedRefresh) {
            diaryOut.textContent += '\n\n(embeddings refresh: ' + exec.embedRefresh + ')';
          }
          return exec;
        } finally {
          if (ticker) clearInterval(ticker);
          dreamBtn.disabled = false;
          refreshDiaryBtn.disabled = false;
        }
      }

      async function refreshDiary() {
        const resp = await getJson('/api/diary/list');
        diarySelect.innerHTML = '';
        for (const f of (resp.files || [])) {
          const opt = document.createElement('option');
          opt.value = f;
          opt.textContent = f.split('/').slice(-1)[0];
          diarySelect.appendChild(opt);
        }
        diaryOut.textContent = '';
      }

      diarySelect.onchange = async () => {
        const p = diarySelect.value;
        if (!p) return;
        const resp = await getJson('/api/read?path=' + encodeURIComponent(p));
        diaryOut.textContent = resp.content || resp.error || 'Error';
      };

      dreamBtn.onclick = async () => doDream(getSelectedModel());

      refreshDiaryBtn.onclick = refreshDiary;

      const memTree = document.getElementById('memTree');
      const fileOut = document.getElementById('fileOut');

      function joinPath(parent, name) {
        const p = String(parent || '').replace(/\/+$/, '');
        const n = String(name || '').replace(/^\/+/, '');
        return p ? (p + '/' + n) : n;
      }

      function makeTreeRow({ name, type, fullPath, depth }) {
        const row = document.createElement('div');
        row.className = 'enkidu-tree-node d-flex align-items-center gap-1 py-1';
        row.style.paddingLeft = (depth * 14) + 'px';

        const toggle = document.createElement('span');
        toggle.className = 'enkidu-tree-toggle text-muted';
        toggle.textContent = (type === 'dir') ? '▸' : '';

        const label = document.createElement('span');
        label.className = 'enkidu-tree-label';
        label.textContent = name;

        const badge = document.createElement('span');
        badge.className = 'badge text-bg-secondary ms-auto';
        badge.textContent = type;

        row.appendChild(toggle);
        row.appendChild(label);
        row.appendChild(badge);

        const children = document.createElement('div');
        children.style.display = 'none';

        row.dataset.type = type;
        row.dataset.path = fullPath;
        row.dataset.depth = String(depth);
        row.dataset.loaded = 'false';
        row.dataset.expanded = 'false';

        async function loadChildren() {
          const p = row.dataset.path || 'memories';
          const resp = await getJson('/api/list?path=' + encodeURIComponent(p));
          if (resp && resp.error) {
            const err = document.createElement('div');
            err.className = 'small text-danger';
            err.style.paddingLeft = ((depth + 1) * 14) + 'px';
            err.textContent = resp.error;
            children.innerHTML = '';
            children.appendChild(err);
            row.dataset.loaded = 'true';
            return;
          }
          const items = Array.isArray(resp.items) ? resp.items : [];
          children.innerHTML = '';
          for (const it of items) {
            const childPath = joinPath(p, it.name);
            const child = makeTreeRow({ name: it.name, type: it.type, fullPath: childPath, depth: depth + 1 });
            children.appendChild(child.container);
          }
          row.dataset.loaded = 'true';
        }

        async function expand() {
          if (type !== 'dir') return;
          row.dataset.expanded = 'true';
          toggle.textContent = '▾';
          if (row.dataset.loaded !== 'true') await loadChildren();
          children.style.display = '';
        }

        function collapse() {
          if (type !== 'dir') return;
          row.dataset.expanded = 'false';
          toggle.textContent = '▸';
          children.style.display = 'none';
        }

        async function toggleDir() {
          if (type !== 'dir') return;
          if (row.dataset.expanded === 'true') collapse();
          else await expand();
        }

        toggle.onclick = async (e) => { e.stopPropagation(); await toggleDir(); };
        label.onclick = async (e) => {
          e.stopPropagation();
          if (type === 'dir') {
            await toggleDir();
            return;
          }
          const r = await getJson('/api/read?path=' + encodeURIComponent(fullPath));
          fileOut.textContent = r.content || r.error || 'Error';
        };

        return { container: document.createElement('div'), row, children };
      }

      function appendTreeRow(parentEl, rowObj) {
        rowObj.container.appendChild(rowObj.row);
        rowObj.container.appendChild(rowObj.children);
        parentEl.appendChild(rowObj.container);
      }

      async function loadMemoriesTree() {
        memTree.innerHTML = '';
        fileOut.textContent = '';

        const root = makeTreeRow({ name: 'memories', type: 'dir', fullPath: 'memories', depth: 0 });
        appendTreeRow(memTree, root);
        // auto-expand root
        root.row.querySelector('.enkidu-tree-toggle').click();
      }

      // Initial load
      renderHistory();
      refreshDiary();
      loadMemoriesTree();
    </script>
  </body>
</html>


